# Разбор уязвимостей сервиса SibirCTF

Всем привет!

На **SibirCTF** вам удалось порешать сервис, разработанный нашей командой.  
Сервис представлял из себя **Биржу по покупке кибервалюты**, где можно было создавать, покупать и продавать продукты. 

В качестве секретной информации использовался контент в продукте, который сохранялся в закодированном виде. Чтобы просмотреть контент, нужно было владеть продуктом. То есть если продукт принадлежал вам, то происходило декодирование контента. 

Поэтому для получения флага можно было:
- накопить достаточно денег и купить продукт с флагом
- получить содержимое продукта с флагом через уязвимость контроля доступа
- декодировать значение контента, разобравшись с криптографией

Рассмотрим эти способы:

---

### 1. Накрутка баланса за счет нескольких аккаунтов

Чтобы получить флаг, можно было купить продукт с флагом. Чтобы накопить достаточно денег, можно было создать несколько пользователей и, покупая продукты одного пользователя, собирать у него деньги.

---

### 2. Уязвимость с нулевым балансом

Уязвимость позволяет бесплатно покупать продукт, если его цена равна остатку баланса. То есть если купить продукт на все деньги, то деньги не отнимутся. Это происходит из-за условия в функции `updateUser`, которое проверяет, нужно ли обновлять баланс:
```
if (param.balance) user.balance = param.balance;
```
Если после покупки обновленный баланс нулевой, то баланс юзера не обновляется. Таким образом, можно использовать две учетки для быстрой накрутки баланса, после чего купить продукт с флагом.

---

### 3. Цепочка уязвимостей: ReDoS → Race Condition

Самая интересная уязвимость — вы могли в коде увидеть регулярное выражение, которое должно было вас смутить и натолкнуть на мысль, что разработчики заложили в сервис **ReDoS**:
```
if (/^REASON: (([a-z])+.)+\s#([0-9])+$/.test(buyInfo.reason))
```
Регулярное выражение находилось в функции покупки продукта. Оно проверяло параметр `reason` в запросе на покупку. 

Если проверить его в специализированном сервисе, можно было сразу получить пэйлоад:

<img src="images/regex.png" width=60% height=60%>

Внимательно изучив код, можно было заметить, что проверка наличия достаточных средств на балансе происходит до валидации `reason`. Однако обновление баланса юзера происходит после анализа регулярки:

<img src="images/regex-code.png" width=70% height=70%>

Поэтому, если сначала отправить запрос, вызывающий DoS:

<img src="images/dos-req.png" width=70% height=70%>

То во время обработки регулярки можно отправить еще несколько запросов на покупку продуктов, которые успешно выполнятся, потому что пройдут проверку условия `(user.balance < product.price)`:

<img src="images/dos-req-2.png" width=70% height=70%>

Например, у юзера было на балансе 300$:

<img src="images/dos-balance.png" width=30% height=30%>

И есть два продукта в магазине:

<img src="images/dos-2-products.png" width=30% height=30%>

Выполнив последовательность запросов, описанную выше, юзер получит оба продукта на аккаунт, заплатив только за один:

<img src="images/dos-result.png" width=30% height=30%>

---

### 4. Незащищенная база данных

База данных торчит наружу:

<img src="images/database.png" width=40% height=40%>

Достаточно подключиться к ней и изменить `ownerId` продукта с флагом на свой, или пополнить баланс своего пользователя, чтобы купить нужный продукт, или снизить цену на продукт с флагом - да что угодно!

<img src="images/database-hack.png" width=60% height=60%>

---

### 5. Уязвимость отсутствия контроля доступа в WS

Если обратить внимание, как приложение получает данные о продуктах, то можно заметить определенный WS-запрос:

<img src="images/ws-request.png" width=80% height=80%>

Запрос содержит json `{"uid":1,"pid":null}`. Изучив его внимательно, становится понятно, что параметр `uid` отвечает за идентификатор юзера, а параметр `pid` - за идентификатор продукта. Если передать `"pid":null`, то возвращаются все продукты.

При этом в декодированном виде приходит контент тех продуктов, идентификатор владельца которых передан в `uid` в запросе. Таким образом, можно отправить повторный запрос с `uid` владельца продукта с флагом и в ответе получить декодированный контент:   

<img src="images/ws-hack.png" width=80% height=80%>

---

### 6. Фейковая криптография и обфускация

Если внимательно прочитать код сервиса, можно заметить, что криптография, которой шифровались данные сервиса — на самом деле **и не криптография вовсе**:  

<img src="images/strong-crypto.png" width=80% height=80%>

Наверное, вас должна была напугать обфускация программного кода, но на самом деле, так как это **TypeScript**, можно было легко декодировать данные, просто перенеся код из функции `verifyContent` в сплойт или исполнив его в интерпретаторе TS:

<img src="images/decode.png" width=80% height=80%>

---

### 7. Скрытый флаг внутри изображения

Если вы обратите внимание на алгоритм генерации картинки, то заметите, что он прячет внутри изображения флаг:

<img src="images/image-create.png" width=60% height=60%>

Чтобы достать флаг обратно, давайте попросим нейросеть написать декодирующую функцию:

<img src="images/deepseek.png" width=60% height=60%>

После чего загрузим картинку и запустим скрипт:

```
$ pip install pillow
$ python decode.py
Decoded message: secret
```

Скрипт прикреплен `writeup/decode.py`

---

### 8. Известный secret для генерации JWT
В .env проекта по умолчанию прописан `SESSION_SECRET`, который является секретом для генерации пользовательских jwt.

Достаточно было изменить `id` и `username` в jwt на любого другого пользователя, подписав токен известным секретом. С получившимся токеном можно было покупать и создавать продукты от имени другого пользователя, видеть в открытом виде его флаг.
